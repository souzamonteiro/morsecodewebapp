<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a2a6c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Morse Code Learning App</title>
    <link rel="icon" href="icons/favicon.ico" type="image/x-icon">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-152x152.png">
    <style>
        /* Base styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            max-width: 800px;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin-top: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        /* Tab navigation */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            flex-wrap: wrap;
        }
        
        .tab {
            padding: 12px 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }
        
        .tab.active {
            border-bottom: 3px solid #fdbb2d;
            color: #fdbb2d;
        }
        
        .tab:hover:not(.active) {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        /* Tab content */
        .tab-content {
            display: none;
            padding: 20px 0;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Morse reference table */
        .morse-table {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }
        
        .morse-item {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            transition: transform 0.2s;
            cursor: pointer;
        }
        
        .morse-item:hover {
            transform: scale(1.05);
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .morse-char {
            font-size: 1.5rem;
            font-weight: bold;
        }
        
        .morse-code {
            font-family: monospace;
            margin-top: 5px;
            color: #fdbb2d;
        }
        
        /* Practice area */
        .practice-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .practice-area .input-group:first-child > div {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .practice-area .input-group:first-child > div button {
            flex: 1;
            min-width: 120px;
        }

        .practice-area .input-group:nth-child(3) > div {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .practice-area .input-group:nth-child(3) > div button {
            flex: 1;
            min-width: 120px;
        }

        .practice-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .practice-controls button {
            flex: 1;
        }
        
        .phrases-management-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .phrases-management-controls button {
            flex: 1;
            min-width: 120px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        label {
            font-weight: bold;
        }
        
        input, textarea, select, button {
            padding: 12px;
            border-radius: 8px;
            border: none;
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1rem;
        }
        
        button {
            background-color: #fdbb2d;
            color: #1a2a6c;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background-color: #ffcc44;
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background-color: #666;
            color: #999;
            cursor: not-allowed;
            transform: none;
        }
        
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            min-height: 60px;
        }
        
        /* Flash card */
        .flashcard {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .flashcard:hover {
            background-color: rgba(255, 255, 255, 0.15);
        }
        
        .flashcard-char {
            font-size: 4rem;
            font-weight: bold;
            margin-bottom: 20px;
        }
        
        .flashcard-code {
            font-family: monospace;
            font-size: 1.5rem;
            color: #fdbb2d;
        }
        
        .hidden {
            display: none;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }
        
        /* Progress tracking */
        .progress-container {
            margin-top: 30px;
        }
        
        .progress-bar {
            height: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }
        
        .progress {
            height: 100%;
            background-color: #fdbb2d;
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .stats {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .stat-item {
            text-align: center;
            flex: 1;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #fdbb2d;
        }
        
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        /* About the app */
        .about-container {
            margin-top: 30px;
        }

        /* CW Key Section */
        .cw-key-section {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .cw-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #b21f1f;
        }
        
        .status-indicator.connected {
            background-color: #4CAF50;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .cw-output {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            min-height: 100px;
            font-family: monospace;
            font-size: 1.2rem;
            margin-top: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .cw-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .cw-controls button {
            flex: 1;
        }
        
        .key-settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }
        
        .key-test-area {
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-top: 20px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
            min-height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            transition: all 0.2s ease;
        }
        
        .key-test-area.active {
            border-color: #fdbb2d;
            background-color: rgba(253, 187, 45, 0.2);
            transform: scale(0.98);
        }
        
        .key-test-area:active {
            transform: scale(0.95);
        }
        
        .touch-instructions {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-top: 10px;
        }
        
        .timing-info {
            font-size: 0.8rem;
            opacity: 0.7;
            margin-top: 5px;
        }
        
        /* Audio controls */
        .audio-controls {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .audio-settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        /* Phrase management */
        .phrases-management {
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .phrases-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        
        .phrase-item {
            padding: 8px;
            margin-bottom: 5px;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .phrase-text {
            flex-grow: 1;
            word-break: break-word;
        }
        
        .phrase-actions {
            display: flex;
            gap: 5px;
            margin-left: 10px;
        }
        
        .phrase-actions button {
            padding: 4px 8px;
            font-size: 0.8rem;
        }
        
        /* Responsive design */
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .tabs {
                flex-wrap: wrap;
            }
            
            .tab {
                flex: 1;
                min-width: 120px;
                text-align: center;
            }
            
            .morse-table {
                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            }
            
            .flashcard-char {
                font-size: 3rem;
            }
            
            .key-settings, .audio-settings {
                grid-template-columns: 1fr;
            }
            
            .phrases-management-controls {
                flex-wrap: wrap;
            }
            
            .phrases-management-controls-button {
                min-width: 120px;
            }
            
            .key-test-area {
                min-height: 120px;
            }

            .practice-area .input-group:first-child > div button,
            .practice-area .input-group:nth-child(3) > div button,
            .phrases-management-controls button {
                min-width: 100%;
            }
            
            @media (max-width: 400px) {
                .practice-area .input-group:first-child > div,
                .practice-area .input-group:nth-child(3) > div,
                .phrases-management-controls {
                    gap: 8px;
                }
                
                .practice-area .input-group:first-child > div button,
                .practice-area .input-group:nth-child(3) > div button,
                .phrases-management-controls button {
                    padding: 10px;
                    font-size: 0.9rem;
                }
            }
        }

        @media (min-width: 601px) and (max-width: 1024px) {
            .practice-area .input-group:first-child > div button,
            .practice-area .input-group:nth-child(3) > div button,
            .phrases-management-controls button {
                min-width: calc(50% - 5px);
            }
        }

        @media (min-width: 1025px) {
            .practice-area .input-group:first-child > div,
            .practice-area .input-group:nth-child(3) > div,
            .phrases-management-controls {
                justify-content: flex-start;
            }
            
            .practice-area .input-group:first-child > div button,
            .practice-area .input-group:nth-child(3) > div button,
            .phrases-management-controls button {
                flex: none;
                width: auto;
                min-width: 140px;
            }
        }
    </style>
</head>
<body>
    <h1>Morse Code Learning App</h1>
    <p class="subtitle">Learn, practice, and master Morse code</p>
    
    <div class="container">
        <!-- Tab navigation -->
        <div class="tabs">
            <div class="tab active" data-tab="learn">Learn</div>
            <div class="tab" data-tab="practice">Practice</div>
            <div class="tab" data-tab="audio">Audio</div>
            <div class="tab" data-tab="cwkey">CW Key</div>
            <div class="tab" data-tab="flashcards">Flashcards</div>
            <div class="tab" data-tab="progress">Progress</div>
            <div class="tab" data-tab="about">About</div>
        </div>
        
        <!-- Learn tab -->
        <div class="tab-content active" id="learn">
            <h2>Morse Code Reference</h2>
            <p>Morse code is a method of transmitting text information as a series of on-off tones, lights, or clicks.</p>
            
            <div class="morse-table" id="morseTable">
                <!-- Morse code table will be generated by JavaScript -->
            </div>
        </div>

        <!-- Practice tab -->
        <div class="tab-content" id="practice">
            <h2>Practice Morse Code</h2>
            <div class="practice-area">
                <div class="input-group">
                    <label for="textInput">Text to convert to Morse:</label>
                    <textarea id="textInput" placeholder="Enter text to convert to Morse code"></textarea>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button id="convertToMorse">Convert to Morse</button>
                        <button id="playText">Play as Audio</button>
                        <button id="getRandomPhrase">Random Phrase</button>
                    </div>
                </div>
                
                <div class="input-group">
                    <label for="morseInput">Morse code to decode:</label>
                    <textarea id="morseInput" placeholder="Enter Morse code (use . for dots and - for dashes, separate letters with spaces)"></textarea>
                    <div style="display: flex; gap: 10px;">
                        <button id="convertToText">Convert to Text</button>
                        <button id="playMorse">Play as Audio</button>
                    </div>
                </div>
                
                <div class="result" id="practiceResult">
                    Result will appear here
                </div>

                <div class="phrases-management">
                    <h3>Practice Phrases Management</h3>
                    <div class="input-group">
                        <label for="newPhrase">Add new practice phrase:</label>
                        <textarea id="newPhrase" placeholder="Enter a new practice phrase"></textarea>
                        <div class="phrases-management-controls">
                            <button id="addPhrase">Add Phrase</button>
                            <button id="importPhrases">Import Phrases</button>
                            <button id="exportPhrases">Export Phrases</button>
                            <button id="clearPhrases" style="background-color: #b21f1f;">Clear All</button>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label><span>Saved Phrases</span> (<span id="phraseCount">0</span>):</label>
                        <div class="phrases-list" id="phrasesList">
                            <!-- Phrases will be loaded here -->
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label for="defaultPhrases">Load default phrases:</label>
                        <select id="defaultPhrases">
                            <option value="">Select a phrase set</option>
                            <option value="basic">Basic Words</option>
                            <option value="common">Common Phrases</option>
                            <option value="radio">Radio Communication</option>
                            <option value="qcodes">Q Codes</option>
                            <option value="proverbs">Proverbs</option>
                        </select>
                        <button id="loadDefaultPhrases">Load Selected</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Audio tab -->
        <div class="tab-content" id="audio">
            <h2>Morse Code Audio</h2>
            <p>Listen to Morse code sounds and practice decoding by ear</p>
            
            <div class="audio-controls">
                <div class="input-group">
                    <label for="audioText">Text to play as Morse code:</label>
                    <textarea id="audioText" placeholder="Enter text to play as Morse code audio">SOS</textarea>
                    <button id="playAudioText">Play Morse Code</button>
                </div>
                
                <br />
                
                <div class="audio-settings">
                    <div class="input-group">
                        <label for="audioFrequency">Tone Frequency (Hz):</label>
                        <input type="range" id="audioFrequency" min="300" max="1000" value="600">
                        <span id="frequencyValue">600 Hz</span>
                    </div>
                    
                    <div class="input-group">
                        <label for="audioSpeed">Playback Speed (WPM):</label>
                        <input type="range" id="audioSpeed" min="5" max="30" value="15">
                        <span id="audioSpeedValue">15 WPM</span>
                    </div>
                </div>
                
                <div class="input-group">
                    <label for="audioVolume">Volume:</label>
                    <input type="range" id="audioVolume" min="0" max="100" value="50">
                    <span id="volumeValue">50%</span>
                </div>
                
                <div class="controls" style="margin-top: 20px;">
                    <button id="stopAudio">Stop Audio</button>
                    <button id="randomText">Random Text</button>
                </div>
                
                <div class="result" id="audioResult" style="margin-top: 20px;">
                    Audio status: Ready
                </div>
            </div>
        </div>
        
        <!-- CW Key tab -->
        <div class="tab-content" id="cwkey">
            <h2>CW Key Interface</h2>
            <p>Connect your USB CW key or use touch/keyboard as a virtual key</p>
            
            <div class="cw-key-section">
                <div class="cw-status">
                    <div class="status-indicator" id="statusIndicator"></div>
                    <span id="statusText">CW Key not connected</span>
                </div>
                
                <div class="input-group">
                    <label for="cwSpeed">CW Speed (WPM):</label>
                    <input type="range" id="cwSpeed" min="5" max="30" value="15">
                    <span id="speedValue">15 WPM</span>
                    <div class="timing-info" id="timingInfo">
                        Dot: 80ms, Dash: 240ms, Char space: 240ms
                    </div>
                </div>
                
                <div class="key-settings">
                    <div class="input-group">
                        <label for="keyMode">Key Mode:</label>
                        <select id="keyMode">
                            <option value="keyboard">Keyboard (Spacebar)</option>
                            <option value="touch">Touch/Click</option>
                            <option value="serial">USB Serial Key</option>
                            <option value="mouse">Mouse Key (L=dot, R=dash)</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label for="serialPort">Serial Port (if applicable):</label>
                        <select id="serialPort">
                            <option value="">No ports available</option>
                        </select>
                    </div>
                </div>
                
                <div class="cw-controls">
                    <button id="connectKey">Connect Key</button>
                    <button id="clearOutput">Clear Output</button>
                    <button id="practiceMode">Practice Mode</button>
                    <button id="enableSound">Enable Sound</button>
                </div>
                
                <div class="key-test-area" id="keyTestArea">
                    <p id="keyTestInstruction">Press your CW key, Spacebar, or Touch here to test</p>
                    <p class="touch-instructions">(Touch and hold for dash, quick tap for dot)</p>
                    <p class="hidden" id="keyOutput"></p>
                </div>
                
                <div class="cw-output" id="cwOutput">
                    CW output will appear here...
                </div>
                
                <div class="input-group" style="margin-top: 15px;">
                    <label>Current Character: <span id="currentCharDisplay" style="color: #fdbb2d; font-weight: bold;">None</span></label>
                    <label>Current Word: <span id="currentWordDisplay" style="color: #fdbb2d; font-weight: bold;">None</span></label>
                </div>
            </div>
        </div>
        
        <!-- Flashcards tab -->
        <div class="tab-content" id="flashcards">
            <h2>Morse Code Flashcards</h2>
            <p>Click on the card to reveal the Morse code</p>
            
            <div class="flashcard" id="flashcard">
                <div class="flashcard-char" id="flashcardChar">A</div>
                <div class="flashcard-code hidden" id="flashcardCode">.-</div>
            </div>
            
            <div class="controls">
                <button id="prevCard">Previous</button>
                <button id="nextCard">Next</button>
                <button id="flipCard">Reveal Code</button>
                <button id="playCardSound">Play Sound</button>
            </div>
            
            <!-- ADD THIS NEW SECTION FOR CW PRACTICE -->
            <div class="cw-key-section" style="margin-top: 30px;">
                <h3>Practice This Character</h3>
                <p>Use your CW key (keyboard, touch, or mouse) to practice sending the displayed character</p>
                
                <div class="key-test-area" id="flashcardKeyTestArea">
                    <p id="flashcardKeyInstruction">Press Spacebar, click, or touch here to practice</p>
                    <p class="touch-instructions">(Touch and hold for dash, quick tap for dot)</p>
                    <p class="hidden" id="flashcardKeyOutput"></p>
                </div>
                
                <div class="cw-controls" style="margin-top: 15px;">
                    <button id="flashcardClearKey">Clear Input</button>
                    <button id="flashcardCheckCode">Check My Code</button>
                    <button id="flashcardShowCode">Show Target Code</button>
                </div>
                
                <div class="cw-output" id="flashcardCwOutput" style="margin-top: 15px; min-height: 60px;">
                    Your CW input will appear here...
                </div>
                
                <div class="input-group" style="margin-top: 15px;">
                    <label>Your Input: <span id="flashcardCurrentCharDisplay" style="color: #fdbb2d; font-weight: bold;">None</span></label>
                    <label>Target Code: <span id="flashcardTargetCodeDisplay" style="color: #4CAF50; font-weight: bold;">.-</span></label>
                </div>
            </div>
            
            <div class="input-group" style="margin-top: 20px;">
                <label for="cardType">Card Type:</label>
                <select id="cardType">
                    <option value="letters">Letters Only</option>
                    <option value="numbers">Numbers Only</option>
                    <option value="both">Letters & Numbers</option>
                </select>
            </div>
        </div>
        
        <!-- Progress tab -->
        <div class="tab-content" id="progress">
            <h2>Your Learning Progress</h2>
            <p>Track your Morse code learning journey</p>
            
            <div class="progress-container">
                <div class="stats">
                    <div class="stat-item">
                        <div class="stat-value" id="lettersLearned">0</div>
                        <div class="stat-label">Letters Learned</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="practiceSessions">0</div>
                        <div class="stat-label">Practice Sessions</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="flashcardsViewed">0</div>
                        <div class="stat-label">Flashcards Viewed</div>
                    </div>
                </div>
                
                <h3 style="margin-top: 30px;">Overall Progress</h3>
                <div class="progress-bar">
                    <div class="progress" id="overallProgress"></div>
                </div>
                
                <button id="resetProgress" style="margin-top: 20px; background-color: #b21f1f;">Reset Progress</button>
            </div>
        </div>

        <!-- About tab -->
        <div class="tab-content" id="about">
            <h2>About Morse Code Learning App</h2>
            <div class="about-container">
                <p>Welcome to the Morse Code Learning App - a comprehensive, progressive web application designed to help you learn, practice, and master Morse code efficiently and enjoyably.</p>
                
                <br />

                <h3>Features</h3>
                <ul style="margin-left: 20px; margin-bottom: 20px;">
                    <li>Learn: Complete Morse code reference table with interactive character learning</li>
                    <li>Practice: Convert text to Morse and vice versa with audio playback</li>
                    <li>Audio Training: Customizable Morse code audio with adjustable speed, frequency, and volume</li>
                    <li>CW Key Interface: Virtual CW key with keyboard, touch, mouse, and Web Serial API support</li>
                    <li>Flashcards: Interactive flashcard system for memorization</li>
                    <li>Progress Tracking: Track your learning progress with statistics</li>
                    <li>Phrase Management: Save, import, export, and organize practice phrases</li>
                    <li>Offline Capable: Works without internet connection (PWA)</li>
                    <li>Responsive Design: Works on desktop, tablet, and mobile devices</li>
                </ul>
                
                <h3>Technical Details</h3>
                <p>This application is built using modern web technologies:</p>
                <ul style="margin-left: 20px; margin-bottom: 20px;">
                    <li>HTML5, CSS3, and Vanilla JavaScript</li>
                    <li>Web Audio API for Morse code sound generation</li>
                    <li>Web Serial API for hardware CW key support (experimental)</li>
                    <li>Progressive Web App (PWA) with service worker</li>
                    <li>LocalStorage for data persistence</li>
                    <li>Responsive CSS Grid and Flexbox layouts</li>
                </ul>
                
                <h3>Morse Code Timing</h3>
                <p>The app uses standard PARIS timing calculation:</p>
                <ul style="margin-left: 20px; margin-bottom: 20px;">
                    <li>Dot duration = 1 time unit</li>
                    <li>Dash duration = 3 time units</li>
                    <li>Intra-character space = 1 time unit</li>
                    <li>Character space = 3 time units</li>
                    <li>Word space = 7 time units</li>
                    <li>PARIS word = 50 time units (standard for WPM calculation)</li>
                </ul>
                <p>Words Per Minute (WPM) calculation: Time unit = 1200 / WPM (in milliseconds)</p>
                
                <br />

                <h3>Project Information</h3>
                <div style="background-color: rgba(255, 255, 255, 0.1); padding: 15px; border-radius: 8px; margin-top: 10px;">
                    <p><strong>GitHub Repository:</strong> <a href="https://github.com/souzamonteiro/morsecodewebapp.git" style="color: #fdbb2d;" target="_blank">morsecodewebapp</a></p>
                    <p><strong>Author:</strong> Roberto Luiz Souza Monteiro</p>
                    <p><strong>License:</strong> Apache License 2.0</p>
                    <p><strong>Version:</strong> 1.0.0</p>
                </div>
                
                <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.2); text-align: center;">
                    <p style="opacity: 0.8;">Made with ❤️ for the amateur radio and Morse code community</p>
                    <p style="font-size: 0.9em; opacity: 0.6;">"CQ CQ CQ DE PU6RLS K"</p>
                </div>
            </div>
        </div>
    </div>

    <script src="i18n.js"></script>
    
    <script>
        // Flashcard CW Practice elements
        const flashcardKeyTestArea = document.getElementById('flashcardKeyTestArea');
        const flashcardKeyInstruction = document.getElementById('flashcardKeyInstruction');
        const flashcardKeyOutput = document.getElementById('flashcardKeyOutput');
        const flashcardClearKeyButton = document.getElementById('flashcardClearKey');
        const flashcardCheckCodeButton = document.getElementById('flashcardCheckCode');
        const flashcardShowCodeButton = document.getElementById('flashcardShowCode');
        const flashcardCwOutput = document.getElementById('flashcardCwOutput');
        const flashcardCurrentCharDisplay = document.getElementById('flashcardCurrentCharDisplay');
        const flashcardTargetCodeDisplay = document.getElementById('flashcardTargetCodeDisplay');

        // Flashcard CW Practice state
        let flashcardCwState = {
            currentCharacter: '',
            keyDownTime: 0,
            soundEnabled: true,
            lastKeyUpTime: 0,
            characterTimeout: null,
            isTouchActive: false,
            touchTimer: null,
            mouseButtonDown: null
        };

        // Morse code dictionary
        const morseCode = {
            'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 
            'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 
            'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 
            'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 
            'Y': '-.--', 'Z': '--..', 
            '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', 
            '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.',
            '.': '.-.-.-', ',': '--..--', '?': '..--..', "'": '.----.', '!': '-.-.--', 
            '/': '-..-.', '(': '-.--.', ')': '-.--.-', '&': '.-...', ':': '---...', 
            ';': '-.-.-.', '=': '-...-', '+': '.-.-.', '-': '-....-', '_': '..--.-', 
            '"': '.-..-.', '$': '...-..-', '@': '.--.-.', ' ': '/'
        };

        // Reverse dictionary for decoding
        const reverseMorse = {};
        for (const [key, value] of Object.entries(morseCode)) {
            reverseMorse[value] = key;
        }

        // User progress data
        let userProgress = {
            lettersLearned: 0,
            practiceSessions: 0,
            flashcardsViewed: 0,
            learnedChars: new Set()
        };

        // Practice phrases data
        let practicePhrases = {
            phrases: [],
            defaultPhraseSets: {
                basic: [
                    "THE", "QUICK", "BROWN", "FOX", "JUMPS", "OVER", "LAZY", "DOG",
                    "HELLO", "WORLD", "CODE", "MORSE", "LEARN", "PRACTICE"
                ],
                common: [
                    "SOS", "HELP", "OK", "YES", "NO", "THANK YOU", "PLEASE",
                    "GOOD MORNING", "GOOD NIGHT", "HOW ARE YOU", "I AM FINE"
                ],
                radio: [
                    "CQ", "QRZ", "QSL", "QTH", "QRM", "QRN", "QSB", "QSY",
                    "73", "88", "AR", "K", "SK", "BT", "DE"
                ],
                qcodes: [
                    "QRG WILL YOU TELL ME MY EXACT FREQUENCY",
                    "QRH DOES MY FREQUENCY VARY",
                    "QRI THE TONE OF MY TRANSMISSION IS",
                    "QRK THE READABILITY OF MY SIGNALS IS",
                    "QRL I AM BUSY",
                    "QRM I AM BEING INTERFERED WITH",
                    "QRN I AM TROUBLED BY STATIC"
                ],
                proverbs: [
                    "A STITCH IN TIME SAVES NINE",
                    "ACTIONS SPEAK LOUDER THAN WORDS",
                    "ALL THAT GLITTERS IS NOT GOLD",
                    "BETTER LATE THAN NEVER",
                    "DON'T COUNT YOUR CHICKENS BEFORE THEY HATCH",
                    "EVERY CLOUD HAS A SILVER LINING"
                ]
            }
        };

        // Current flashcard index
        let currentCardIndex = 0;
        let currentCardSet = [];

        // CW Key state
        let cwKeyState = {
            connected: false,
            port: null,
            reader: null,
            writer: null,
            currentCharacter: '',
            currentWord: '',
            outputText: '',
            speed: 15, // words per minute
            dotDuration: 0, // calculated based on speed
            dashDuration: 0, // calculated based on speed
            charSpaceDuration: 0, // space between characters
            wordSpaceDuration: 0, // space between words
            keyDownTime: 0,
            practiceMode: false,
            practiceText: '',
            practiceIndex: 0,
            soundEnabled: true,
            isTouchActive: false,
            touchTimer: null,
            characterTimeout: null, // timeout for character completion
            lastKeyUpTime: 0, // track when key was last released
            mouseButtonDown: null, // track which mouse button is pressed
            wordSpaceInterval: null // interval for checking word spaces
        };

        // Audio state
        let audioState = {
            audioContext: null,
            oscillator: null,
            isPlaying: false,
            frequency: 600,
            volume: 0.5,
            speed: 15,
            dotDuration: 0,
            dashDuration: 0,
            characterSpace: 0,
            wordSpace: 0,
            continuousTone: false
        };

        // DOM elements
        const tabElements = document.querySelectorAll('.tab');
        const tabContentElements = document.querySelectorAll('.tab-content');
        const morseTableElement = document.getElementById('morseTable');
        const textInputElement = document.getElementById('textInput');
        const morseInputElement = document.getElementById('morseInput');
        const convertToMorseButton = document.getElementById('convertToMorse');
        const convertToTextButton = document.getElementById('convertToText');
        const practiceResultElement = document.getElementById('practiceResult');
        const flashcardElement = document.getElementById('flashcard');
        const flashcardCharElement = document.getElementById('flashcardChar');
        const flashcardCodeElement = document.getElementById('flashcardCode');
        const prevCardButton = document.getElementById('prevCard');
        const nextCardButton = document.getElementById('nextCard');
        const flipCardButton = document.getElementById('flipCard');
        const playCardSoundButton = document.getElementById('playCardSound');
        const cardTypeElement = document.getElementById('cardType');
        const lettersLearnedElement = document.getElementById('lettersLearned');
        const practiceSessionsElement = document.getElementById('practiceSessions');
        const flashcardsViewedElement = document.getElementById('flashcardsViewed');
        const overallProgressElement = document.getElementById('overallProgress');
        const resetProgressButton = document.getElementById('resetProgress');
        
        // CW Key elements
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const cwSpeed = document.getElementById('cwSpeed');
        const speedValue = document.getElementById('speedValue');
        const timingInfo = document.getElementById('timingInfo');
        const keyMode = document.getElementById('keyMode');
        const serialPort = document.getElementById('serialPort');
        const connectKeyButton = document.getElementById('connectKey');
        const clearOutputButton = document.getElementById('clearOutput');
        const practiceModeButton = document.getElementById('practiceMode');
        const enableSoundButton = document.getElementById('enableSound');
        const keyTestArea = document.getElementById('keyTestArea');
        const keyTestInstruction = document.getElementById('keyTestInstruction');
        const keyOutput = document.getElementById('keyOutput');
        const cwOutput = document.getElementById('cwOutput');
        const currentCharDisplay = document.getElementById('currentCharDisplay');
        const currentWordDisplay = document.getElementById('currentWordDisplay');
        
        // Audio elements
        const audioTextElement = document.getElementById('audioText');
        const playAudioTextButton = document.getElementById('playAudioText');
        const audioFrequencyElement = document.getElementById('audioFrequency');
        const frequencyValueElement = document.getElementById('frequencyValue');
        const audioSpeedElement = document.getElementById('audioSpeed');
        const audioSpeedValueElement = document.getElementById('audioSpeedValue');
        const audioVolumeElement = document.getElementById('audioVolume');
        const volumeValueElement = document.getElementById('volumeValue');
        const stopAudioButton = document.getElementById('stopAudio');
        const randomTextButton = document.getElementById('randomText');
        const audioResultElement = document.getElementById('audioResult');
        const playTextButton = document.getElementById('playText');
        const playMorseButton = document.getElementById('playMorse');
        
        // Practice phrases elements
        const newPhraseElement = document.getElementById('newPhrase');
        const addPhraseButton = document.getElementById('addPhrase');
        const importPhrasesButton = document.getElementById('importPhrases');
        const exportPhrasesButton = document.getElementById('exportPhrases');
        const clearPhrasesButton = document.getElementById('clearPhrases');
        const getRandomPhraseButton = document.getElementById('getRandomPhrase');
        const phrasesListElement = document.getElementById('phrasesList');
        const phraseCountElement = document.getElementById('phraseCount');
        const defaultPhrasesElement = document.getElementById('defaultPhrases');
        const loadDefaultPhrasesButton = document.getElementById('loadDefaultPhrases');

        // Initialize the app
        function init() {
            // Load audio settings from localStorage
            loadAudioSettings();

            // Load CW settings from localStorage  
            loadCwSettings();

            // Load user progress from localStorage
            loadProgress();
            
            // Load practice phrases from localStorage
            loadPracticePhrases();
            
            // Generate Morse code table
            generateMorseTable();
            
            // Initialize flashcards
            generateCardSet();
            showCard();
            
            // Initialize CW Key
            initCwKey();
            loadCwSettings();
            
            // Initialize Audio
            initAudio();

            // Initialize Flashcard CW Practice
            initFlashcardCwPractice();

            // Update progress display
            updateProgressDisplay();
            
            // Update phrases display
            updatePhrasesDisplay();
            
            // Set up event listeners
            setupEventListeners();
        }

        // Save CW settings to localStorage
        function saveCwSettings() {
            const cwSettings = {
                speed: cwKeyState.speed,
                soundEnabled: cwKeyState.soundEnabled,
                keyMode: keyMode.value
            };
            localStorage.setItem('morseCodeCwSettings', JSON.stringify(cwSettings));
        }

        // Load CW settings from localStorage
        function loadCwSettings() {
            const savedSettings = localStorage.getItem('morseCodeCwSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    cwKeyState.speed = settings.speed || 15;
                    cwKeyState.soundEnabled = settings.soundEnabled !== undefined ? settings.soundEnabled : true;
                    
                    // Update UI controls
                    cwSpeed.value = cwKeyState.speed;
                    speedValue.textContent = `${cwKeyState.speed} WPM`;
                    
                    if (settings.keyMode) {
                        keyMode.value = settings.keyMode;
                        updateKeyInstruction();
                        updateFlashcardKeyInstruction();
                    }
                    
                    // Update button states
                    if (cwKeyState.soundEnabled) {
                        enableSoundButton.textContent = 'Disable Sound';
                        enableSoundButton.style.backgroundColor = '#4CAF50';
                    } else {
                        enableSoundButton.textContent = 'Enable Sound';
                        enableSoundButton.style.backgroundColor = '#fdbb2d';
                    }
                    
                    // Update timing
                    updateCwTiming();
                } catch (e) {
                    console.error('Error loading CW settings:', e);
                }
            }
        }

        // Initialize CW Key functionality
        function initCwKey() {
            // Calculate initial durations based on speed
            updateCwTiming();
            
            // Update speed display
            speedValue.textContent = `${cwSpeed.value} WPM`;
            
            // Check for Web Serial API support
            if ('serial' in navigator) {
                statusText.textContent = 'Web Serial API supported';
            } else {
                statusText.textContent = 'Web Serial API not supported - use keyboard/touch/mouse mode';
                keyMode.value = 'keyboard';
                serialPort.disabled = true;
            }
            
            // Load practice text
            cwKeyState.practiceText = generatePracticeText();
            
            // Update instruction text based on mode
            updateKeyInstruction();
            
            // Initialize character and word displays
            currentCharDisplay.textContent = 'None';
            currentWordDisplay.textContent = 'None';
            
            // Initialize the word space checking interval
            startWordSpaceChecker();
        }

        // Start checking for word spaces
        function startWordSpaceChecker() {
            // Clear any existing interval
            if (cwKeyState.wordSpaceInterval) {
                clearInterval(cwKeyState.wordSpaceInterval);
            }
            
            // Check regularly for word space timeout
            cwKeyState.wordSpaceInterval = setInterval(() => {
                if (cwKeyState.currentWord && cwKeyState.lastKeyUpTime && 
                    (Date.now() - cwKeyState.lastKeyUpTime) > cwKeyState.wordSpaceDuration) {
                    processWordSpace();
                }
            }, 50); // Check every 50ms
        }

        // Update CW timing based on speed (WPM)
        function updateCwTiming() {
            // Standard PARIS calculation: 50 time units per word
            // Dot = 1 unit, Dash = 3 units, intra-character space = 1 unit
            // Character space = 3 units, Word space = 7 units
            const timeUnit = 1200 / cwKeyState.speed; // milliseconds per unit
            
            cwKeyState.dotDuration = timeUnit;
            cwKeyState.dashDuration = timeUnit * 3;
            cwKeyState.charSpaceDuration = timeUnit * 3; // Space between characters
            cwKeyState.wordSpaceDuration = timeUnit * 7; // Space between words
            
            // Update timing info display
            timingInfo.textContent = `Dot: ${Math.round(cwKeyState.dotDuration)}ms, Dash: ${Math.round(cwKeyState.dashDuration)}ms, Char space: ${Math.round(cwKeyState.charSpaceDuration)}ms`;
            
            // Restart word space checker with new timing
            startWordSpaceChecker();
        }

        // Update key instruction text based on selected mode
        function updateKeyInstruction() {
            const mode = keyMode.value;
            if (mode === 'touch') {
                keyTestInstruction.textContent = 'Touch and hold here to test';
            } else if (mode === 'keyboard') {
                keyTestInstruction.textContent = 'Press Spacebar or click here to test';
            } else if (mode === 'mouse') {
                keyTestInstruction.textContent = 'Left click for dot, Right click for dash (click here to focus)';
            } else {
                keyTestInstruction.textContent = 'Press your CW key to test';
            }
        }

        // Save audio settings to localStorage
        function saveAudioSettings() {
            const audioSettings = {
                frequency: audioState.frequency,
                volume: audioState.volume,
                speed: audioState.speed
            };
            localStorage.setItem('morseCodeAudioSettings', JSON.stringify(audioSettings));
        }

        // Load audio settings from localStorage
        function loadAudioSettings() {
            const savedSettings = localStorage.getItem('morseCodeAudioSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    audioState.frequency = settings.frequency || 600;
                    audioState.volume = settings.volume || 0.5;
                    audioState.speed = settings.speed || 15;
                    
                    // Update UI controls to match loaded values
                    audioFrequencyElement.value = audioState.frequency;
                    frequencyValueElement.textContent = `${audioState.frequency} Hz`;
                    
                    audioSpeedElement.value = audioState.speed;
                    audioSpeedValueElement.textContent = `${audioState.speed} WPM`;
                    
                    audioVolumeElement.value = Math.round(audioState.volume * 100);
                    volumeValueElement.textContent = `${Math.round(audioState.volume * 100)}%`;
                    
                    // Update audio timing
                    updateAudioTiming();
                } catch (e) {
                    console.error('Error loading audio settings:', e);
                }
            }
        }

        // Initialize Audio functionality
        function initAudio() {
            // Initialize Web Audio API
            try {
                audioState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Update audio timing based on speed
                updateAudioTiming();
                
                // Set initial values for controls
                frequencyValueElement.textContent = `${audioFrequencyElement.value} Hz`;
                audioSpeedValueElement.textContent = `${audioSpeedElement.value} WPM`;
                volumeValueElement.textContent = `${audioVolumeElement.value}%`;
                
                audioResultElement.textContent = 'Audio status: Ready';
            } catch (error) {
                console.error('Error initializing audio:', error);
                audioResultElement.textContent = 'Audio not supported in this browser';
                playAudioTextButton.disabled = true;
                playCardSoundButton.disabled = true;
                playTextButton.disabled = true;
                playMorseButton.disabled = true;
            }
        }

        // Load practice phrases from localStorage
        function loadPracticePhrases() {
            const savedPhrases = localStorage.getItem('morseCodePhrases');
            if (savedPhrases) {
                try {
                    practicePhrases.phrases = JSON.parse(savedPhrases);
                } catch (e) {
                    console.error('Error loading phrases:', e);
                    practicePhrases.phrases = [];
                }
            }
        }

        // Save practice phrases to localStorage
        function savePracticePhrases() {
            localStorage.setItem('morseCodePhrases', JSON.stringify(practicePhrases.phrases));
        }

        // Update phrases display
        function updatePhrasesDisplay() {
            phrasesListElement.innerHTML = '';
            phraseCountElement.textContent = practicePhrases.phrases.length;
            
            if (practicePhrases.phrases.length === 0) {
                phrasesListElement.innerHTML = '<p style="text-align: center; opacity: 0.7;">No phrases saved yet. Add some phrases to practice!</p>';
                return;
            }
            
            practicePhrases.phrases.forEach((phrase, index) => {
                const phraseItem = document.createElement('div');
                phraseItem.className = 'phrase-item';
                
                const phraseText = document.createElement('div');
                phraseText.className = 'phrase-text';
                phraseText.textContent = phrase;
                
                const phraseActions = document.createElement('div');
                phraseActions.className = 'phrase-actions';
                
                const useButton = document.createElement('button');
                useButton.textContent = 'Use';
                useButton.title = 'Load this phrase into the text area';
                useButton.addEventListener('click', () => {
                    const practiceTab = document.querySelector('[data-tab="practice"]');
                    const practiceContent = document.getElementById('practice');
                    
                    if (!practiceContent.classList.contains('active')) {
                        tabElements.forEach(t => t.classList.remove('active'));
                        tabContentElements.forEach(c => c.classList.remove('active'));
                        
                        practiceTab.classList.add('active');
                        practiceContent.classList.add('active');
                    }
                    
                    textInputElement.value = phrase;
                    
                    textInputElement.focus();
                });
                
                const playButton = document.createElement('button');
                playButton.textContent = 'Play';
                playButton.title = 'Play this phrase as Morse code';
                playButton.addEventListener('click', () => {
                    textInputElement.value = phrase;
                    playMorseFromText(phrase);
                });
                
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.title = 'Delete this phrase';
                deleteButton.style.backgroundColor = '#b21f1f';
                deleteButton.addEventListener('click', () => {
                    if (confirm(`Delete phrase: "${phrase}"?`)) {
                        practicePhrases.phrases.splice(index, 1);
                        savePracticePhrases();
                        updatePhrasesDisplay();
                    }
                });
                
                phraseActions.appendChild(useButton);
                phraseActions.appendChild(playButton);
                phraseActions.appendChild(deleteButton);
                
                phraseItem.appendChild(phraseText);
                phraseItem.appendChild(phraseActions);
                
                phrasesListElement.appendChild(phraseItem);
            });
        }

        // Add a new practice phrase
        function addPracticePhrase() {
            const phrase = newPhraseElement.value.trim();
            if (!phrase) {
                alert('Please enter a phrase');
                return;
            }
            
            if (practicePhrases.phrases.includes(phrase)) {
                alert('This phrase already exists');
                return;
            }
            
            practicePhrases.phrases.push(phrase);
            savePracticePhrases();
            updatePhrasesDisplay();
            newPhraseElement.value = '';
            
            // Also add to text input for immediate use
            textInputElement.value = phrase;
        }

        // Get a random practice phrase
        function getRandomPracticePhrase() {
            if (practicePhrases.phrases.length === 0) {
                alert('No phrases available. Please add some phrases first.');
                return;
            }
            
            const randomIndex = Math.floor(Math.random() * practicePhrases.phrases.length);
            const randomPhrase = practicePhrases.phrases[randomIndex];
            textInputElement.value = randomPhrase;
            
            // Update practice result to show which phrase was selected
            practiceResultElement.textContent = `Random phrase selected: "${randomPhrase}"`;
        }

        // Export phrases to a file (JSON or TXT)
        function exportPhrases() {
            if (practicePhrases.phrases.length === 0) {
                alert('No phrases to export');
                return;
            }
            
            // Ask user which format they want
            const format = confirm('Export as JSON (Cancel) or Text file (OK)?\n\nCancel = JSON format (recommended)\nOK = Text file (one phrase per line)');
            
            let dataStr, fileName, mimeType;
            
            if (!format) {
                // Export as JSON
                const exportData = {
                    phrases: practicePhrases.phrases,
                    exportDate: new Date().toISOString(),
                    totalPhrases: practicePhrases.phrases.length
                };
                dataStr = JSON.stringify(exportData, null, 2);
                fileName = 'morse_code_practice_phrases.json';
                mimeType = 'application/json';
            } else {
                // Export as plain text (one phrase per line)
                dataStr = practicePhrases.phrases.join('\n');
                fileName = 'morse_code_practice_phrases.txt';
                mimeType = 'text/plain';
            }
            
            const dataBlob = new Blob([dataStr], {type: mimeType});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Import phrases from a JSON file or text file
        function importPhrases() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.txt,.text';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        let importedPhrases = [];
                        const fileContent = event.target.result;
                        
                        // Try to parse as JSON first
                        try {
                            const jsonData = JSON.parse(fileContent);
                            if (Array.isArray(jsonData)) {
                                importedPhrases = jsonData;
                            } else if (typeof jsonData === 'object' && jsonData.phrases) {
                                // Support for our export format
                                importedPhrases = jsonData.phrases;
                            } else {
                                throw new Error('JSON is not in expected format');
                            }
                        } catch (jsonError) {
                            // If not JSON, treat as plain text
                            // Split by newlines and filter out empty lines
                            importedPhrases = fileContent.split('\n')
                                .map(line => line.trim())
                                .filter(line => line.length > 0);
                        }
                        
                        if (!Array.isArray(importedPhrases)) {
                            throw new Error('Invalid format: Expected an array of phrases or text file with one phrase per line');
                        }
                        
                        // Add only new phrases
                        let addedCount = 0;
                        importedPhrases.forEach(phrase => {
                            const trimmedPhrase = String(phrase).trim();
                            if (trimmedPhrase && !practicePhrases.phrases.includes(trimmedPhrase)) {
                                practicePhrases.phrases.push(trimmedPhrase);
                                addedCount++;
                            }
                        });
                        
                        savePracticePhrases();
                        updatePhrasesDisplay();
                        alert(`Successfully imported ${addedCount} new phrases.`);
                    } catch (error) {
                        alert(`Error importing phrases: ${error.message}\n\nSupported formats:\n1. JSON array: ["phrase1", "phrase2"]\n2. JSON object with "phrases" key\n3. Text file with one phrase per line`);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // Load default phrases
        function loadDefaultPhrases() {
            const selectedSet = defaultPhrasesElement.value;
            if (!selectedSet) {
                alert('Please select a phrase set');
                return;
            }
            
            const defaultSet = practicePhrases.defaultPhraseSets[selectedSet];
            if (!defaultSet) {
                alert('Selected phrase set not found');
                return;
            }
            
            // Add only new phrases
            let addedCount = 0;
            defaultSet.forEach(phrase => {
                const trimmedPhrase = String(phrase).trim();
                if (trimmedPhrase && !practicePhrases.phrases.includes(trimmedPhrase)) {
                    practicePhrases.phrases.push(trimmedPhrase);
                    addedCount++;
                }
            });
            
            savePracticePhrases();
            updatePhrasesDisplay();
            alert(`Loaded ${addedCount} phrases from the ${selectedSet} set.`);
        }

        // Update audio timing based on speed (WPM)
        function updateAudioTiming() {
            // Standard PARIS calculation
            const timeUnit = 1200 / audioState.speed; // milliseconds per unit
            
            audioState.dotDuration = timeUnit;
            audioState.dashDuration = timeUnit * 3;
            audioState.characterSpace = timeUnit * 3;
            audioState.wordSpace = timeUnit * 7;
        }

        // Generate random practice text
        function generatePracticeText() {
            const words = [
                'THE', 'QUICK', 'BROWN', 'FOX', 'JUMPS', 'OVER', 'LAZY', 'DOG',
                'CODE', 'MORSE', 'LEARN', 'PRACTICE', 'SKILL', 'AMATEUR', 'RADIO',
                'SIGNAL', 'TRANSMIT', 'RECEIVE', 'MESSAGE', 'COMMUNICATION'
            ];
            
            let text = '';
            for (let i = 0; i < 5; i++) {
                text += words[Math.floor(Math.random() * words.length)] + ' ';
            }
            return text.trim();
        }

        // Generate random text for audio practice
        function generateRandomText() {
            const words = [
                'HELLO', 'WORLD', 'MORSE', 'CODE', 'RADIO', 'AMATEUR',
                'SIGNAL', 'TRANSMIT', 'MESSAGE', 'LEARNING', 'PRACTICE',
                'QUICK', 'BROWN', 'FOX', 'JUMPS', 'LAZY', 'DOG'
            ];
            
            let text = '';
            const wordCount = 3 + Math.floor(Math.random() * 4);
            for (let i = 0; i < wordCount; i++) {
                text += words[Math.floor(Math.random() * words.length)] + ' ';
            }
            return text.trim();
        }

        // Play a continuous tone (for real-time keying)
        function startTone() {
            if (!audioState.audioContext || audioState.isPlaying) return;
            
            try {
                audioState.isPlaying = true;
                audioState.continuousTone = true;
                
                // Create oscillator
                audioState.oscillator = audioState.audioContext.createOscillator();
                const gainNode = audioState.audioContext.createGain();
                
                // Configure oscillator
                audioState.oscillator.type = 'sine';
                audioState.oscillator.frequency.value = audioState.frequency;
                
                // Configure gain (volume)
                gainNode.gain.value = audioState.volume;
                
                // Connect nodes
                audioState.oscillator.connect(gainNode);
                gainNode.connect(audioState.audioContext.destination);
                
                // Start oscillator (it will continue until stopped)
                audioState.oscillator.start();
                
            } catch (error) {
                console.error('Error playing tone:', error);
                audioState.isPlaying = false;
                audioState.continuousTone = false;
            }
        }

        // Stop the continuous tone
        function stopTone() {
            if (audioState.oscillator && audioState.continuousTone) {
                try {
                    audioState.oscillator.stop();
                    audioState.oscillator = null;
                    audioState.isPlaying = false;
                    audioState.continuousTone = false;
                } catch (e) {
                    // Ignore errors if oscillator already stopped
                }
            }
        }

        // Play a tone for a specified duration
        function playTone(duration) {
            if (!audioState.audioContext || audioState.isPlaying) return;
            
            try {
                audioState.isPlaying = true;
                
                // Create oscillator
                audioState.oscillator = audioState.audioContext.createOscillator();
                const gainNode = audioState.audioContext.createGain();
                
                // Configure oscillator
                audioState.oscillator.type = 'sine';
                audioState.oscillator.frequency.value = audioState.frequency;
                
                // Configure gain (volume)
                gainNode.gain.value = audioState.volume;
                
                // Connect nodes
                audioState.oscillator.connect(gainNode);
                gainNode.connect(audioState.audioContext.destination);
                
                // Start and stop oscillator
                audioState.oscillator.start();
                
                setTimeout(() => {
                    if (audioState.oscillator && !audioState.continuousTone) {
                        audioState.oscillator.stop();
                        audioState.isPlaying = false;
                    }
                }, duration);
                
            } catch (error) {
                console.error('Error playing tone:', error);
                audioState.isPlaying = false;
            }
        }

        // Play Morse code from text
        async function playMorseFromText(text) {
            if (!audioState.audioContext) {
                audioResultElement.textContent = 'Audio not initialized';
                return;
            }
            
            if (audioState.isPlaying) {
                audioResultElement.textContent = 'Audio already playing';
                return;
            }
            
            audioResultElement.textContent = 'Playing...';
            
            const morse = textToMorse(text.toUpperCase());
            await playMorseSequence(morse);
            
            audioResultElement.textContent = 'Finished playing';
        }

        // Play Morse code sequence
        async function playMorseSequence(morse) {
            for (let i = 0; i < morse.length; i++) {
                const symbol = morse[i];
                
                if (symbol === '.') {
                    // Play dot
                    playTone(audioState.dotDuration);
                    await sleep(audioState.dotDuration);
                } else if (symbol === '-') {
                    // Play dash
                    playTone(audioState.dashDuration);
                    await sleep(audioState.dashDuration);
                } else if (symbol === ' ') {
                    // Character space
                    await sleep(audioState.characterSpace - audioState.dotDuration);
                } else if (symbol === '/') {
                    // Word space (already have character space, so add the difference)
                    await sleep(audioState.wordSpace - audioState.characterSpace);
                }
                
                // Intra-character space (except after last symbol in sequence)
                if (i < morse.length - 1 && morse[i+1] !== ' ' && morse[i+1] !== '/') {
                    await sleep(audioState.dotDuration);
                }
            }
        }

        // Play Morse code for a single character
        async function playCharacter(char) {
            if (!audioState.audioContext) return;
            
            const morse = morseCode[char.toUpperCase()];
            if (!morse) return;
            
            await playMorseSequence(morse);
        }

        // Stop all audio
        function stopAudio() {
            if (audioState.oscillator) {
                try {
                    audioState.oscillator.stop();
                    audioState.oscillator = null;
                } catch (e) {
                    // Ignore errors if oscillator already stopped
                }
            }
            audioState.isPlaying = false;
            audioState.continuousTone = false;
            audioResultElement.textContent = 'Audio stopped';
        }

        // Utility function for sleeping
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Handle mouse button events for mouse key mode
        function handleMouseDown(event) {
            if (keyMode.value !== 'mouse') return;
            
            // Prevent context menu on right click
            if (event.button === 2) {
                event.preventDefault();
            }
            
            // Clear any existing character timeout
            if (cwKeyState.characterTimeout) {
                clearTimeout(cwKeyState.characterTimeout);
                cwKeyState.characterTimeout = null;
            }
            
            cwKeyState.mouseButtonDown = event.button;
            cwKeyState.keyDownTime = Date.now();
            
            // Update display based on which button
            if (event.button === 0) {
                keyOutput.textContent = 'MOUSE DOWN - LEFT (DOT)';
            } else if (event.button === 2) {
                keyOutput.textContent = 'MOUSE DOWN - RIGHT (DASH)';
            }
            keyOutput.classList.remove('hidden');
            
            // Play sound if enabled
            if (cwKeyState.soundEnabled && audioState.audioContext) {
                startTone();
            }
        }

        function handleMouseUp(event) {
            if (keyMode.value !== 'mouse' || cwKeyState.mouseButtonDown === null) return;
            
            // Only process if the same button is released
            if (event.button !== cwKeyState.mouseButtonDown) return;
            
            const duration = Date.now() - cwKeyState.keyDownTime;
            
            // Stop sound if playing
            if (audioState.isPlaying) {
                stopTone();
            }
            
            // Add dot or dash based on which button was pressed
            if (event.button === 0) {
                // Left button = dot
                cwKeyState.currentCharacter += '.';
                keyOutput.textContent = `MOUSE UP - LEFT (DOT) - ${Math.round(duration)}ms`;
            } else if (event.button === 2) {
                // Right button = dash
                cwKeyState.currentCharacter += '-';
                keyOutput.textContent = `MOUSE UP - RIGHT (DASH) - ${Math.round(duration)}ms`;
            }
            
            // Update the current character display
            currentCharDisplay.textContent = cwKeyState.currentCharacter || 'None';
            
            // Set a timeout to complete the character
            cwKeyState.characterTimeout = setTimeout(() => {
                processCharacterSpace();
            }, cwKeyState.charSpaceDuration);
            
            // Update the last key up time
            cwKeyState.lastKeyUpTime = Date.now();
            
            // Update output display
            updateCwOutput();
            
            // Reset mouse button state
            cwKeyState.mouseButtonDown = null;
        }

        // Connect to serial port for CW key
        async function connectSerial() {
            try {
                // Request serial port
                const port = await navigator.serial.requestPort();
                await port.open({ baudRate: 9600 });
                
                cwKeyState.port = port;
                cwKeyState.connected = true;
                
                // Update UI
                statusIndicator.classList.add('connected');
                statusText.textContent = `Connected to ${port.getInfo().usbProductId || 'CW Key'}`;
                connectKeyButton.textContent = 'Disconnect Key';
                
                // Set up reading from the port
                readFromSerialPort(port);
                
            } catch (error) {
                console.error('Error connecting to serial port:', error);
                statusText.textContent = `Connection failed: ${error.message}`;
            }
        }

        // Read data from serial port
        async function readFromSerialPort(port) {
            try {
                const reader = port.readable.getReader();
                cwKeyState.reader = reader;
                
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        reader.releaseLock();
                        break;
                    }
                    
                    // Process incoming data (assuming simple key up/down signals)
                    if (value) {
                        // For a typical CW key, we might get:
                        // - A specific byte when key is pressed
                        // - Another when key is released
                        // This would depend on the specific hardware
                        handleKeyInput(value);
                    }
                }
            } catch (error) {
                console.error('Error reading from serial port:', error);
                disconnectSerial();
            }
        }

        // Handle key input from serial or other sources
        function handleKeyInput(data) {
            // This is a simplified implementation
            // Real implementation would depend on the specific hardware protocol
            
            // For demonstration, we'll assume:
            // - Byte 0x01 means key down
            // - Byte 0x00 means key up
            if (data[0] === 0x01) {
                keyDown();
            } else if (data[0] === 0x00) {
                keyUp();
            }
        }

        // Disconnect from serial port
        async function disconnectSerial() {
            if (cwKeyState.reader) {
                await cwKeyState.reader.cancel();
                cwKeyState.reader = null;
            }
            
            if (cwKeyState.writer) {
                await cwKeyState.writer.close();
                cwKeyState.writer = null;
            }
            
            if (cwKeyState.port) {
                await cwKeyState.port.close();
                cwKeyState.port = null;
            }
            
            cwKeyState.connected = false;
            statusIndicator.classList.remove('connected');
            statusText.textContent = 'CW Key disconnected';
            connectKeyButton.textContent = 'Connect Key';
        }

        // Handle key down (pressing the CW key)
        function keyDown() {
            // Clear any existing character timeout
            if (cwKeyState.characterTimeout) {
                clearTimeout(cwKeyState.characterTimeout);
                cwKeyState.characterTimeout = null;
            }
            
            cwKeyState.keyDownTime = Date.now();
            keyTestArea.classList.add('active');
            keyOutput.textContent = 'KEY DOWN';
            keyOutput.classList.remove('hidden');
            
            // Play sound if enabled
            if (cwKeyState.soundEnabled && audioState.audioContext) {
                startTone();
            }
        }

        // Handle key up (releasing the CW key)
        function keyUp() {
            const duration = Date.now() - cwKeyState.keyDownTime;
            keyTestArea.classList.remove('active');
            keyOutput.textContent = `KEY UP (${Math.round(duration)}ms)`;
            
            // Stop sound if playing
            if (audioState.isPlaying) {
                stopTone();
            }
            
            // Determine if it's a dot or dash based on duration
            if (duration < cwKeyState.dotDuration * 1.5) {
                // Dot
                cwKeyState.currentCharacter += '.';
                keyOutput.textContent += ' - DOT';
            } else {
                // Dash
                cwKeyState.currentCharacter += '-';
                keyOutput.textContent += ' - DASH';
            }
            
            // Update the current character display
            currentCharDisplay.textContent = cwKeyState.currentCharacter || 'None';
            
            // Clear any existing character timeout
            if (cwKeyState.characterTimeout) {
                clearTimeout(cwKeyState.characterTimeout);
            }
            
            // Set a timeout to complete the character
            cwKeyState.characterTimeout = setTimeout(() => {
                processCharacterSpace();
            }, cwKeyState.charSpaceDuration);
            
            // Update the last key up time for word space calculation
            cwKeyState.lastKeyUpTime = Date.now();
            
            // Update output display
            updateCwOutput();
        }

        // Handle touch start
        function touchStart() {
            if (keyMode.value !== 'touch') return;
            
            // Clear any existing character timeout
            if (cwKeyState.characterTimeout) {
                clearTimeout(cwKeyState.characterTimeout);
                cwKeyState.characterTimeout = null;
            }
            
            cwKeyState.keyDownTime = Date.now();
            keyTestArea.classList.add('active');
            keyOutput.textContent = 'TOUCH START';
            keyOutput.classList.remove('hidden');
            
            // Play sound if enabled
            if (cwKeyState.soundEnabled && audioState.audioContext) {
                startTone();
            }
            
            // Set a timer to show we're in dash mode
            cwKeyState.touchTimer = setTimeout(() => {
                keyOutput.textContent = 'TOUCH START - DASH MODE';
            }, cwKeyState.dotDuration * 1.5);
        }

        // Handle touch end
        function touchEnd() {
            if (keyMode.value !== 'touch' || !cwKeyState.keyDownTime) return;
            
            const duration = Date.now() - cwKeyState.keyDownTime;
            keyTestArea.classList.remove('active');
            keyOutput.textContent = `TOUCH END (${Math.round(duration)}ms)`;
            
            // Clear the dash mode timer
            if (cwKeyState.touchTimer) {
                clearTimeout(cwKeyState.touchTimer);
                cwKeyState.touchTimer = null;
            }
            
            // Stop sound if playing
            if (audioState.isPlaying) {
                stopTone();
            }
            
            // Determine if it's a dot or dash based on duration
            if (duration < cwKeyState.dotDuration * 1.5) {
                // Dot
                cwKeyState.currentCharacter += '.';
                keyOutput.textContent += ' - DOT';
            } else {
                // Dash
                cwKeyState.currentCharacter += '-';
                keyOutput.textContent += ' - DASH';
            }
            
            // Update the current character display
            currentCharDisplay.textContent = cwKeyState.currentCharacter || 'None';
            
            // Set a timeout to complete the character
            cwKeyState.characterTimeout = setTimeout(() => {
                processCharacterSpace();
            }, cwKeyState.charSpaceDuration);
            
            // Update the last key up time
            cwKeyState.lastKeyUpTime = Date.now();
            
            // Update output display
            updateCwOutput();
            
            // Reset key down time
            cwKeyState.keyDownTime = 0;
        }

        // Process character space (when a character is complete)
        function processCharacterSpace() {
            // Clear the character timeout
            if (cwKeyState.characterTimeout) {
                clearTimeout(cwKeyState.characterTimeout);
                cwKeyState.characterTimeout = null;
            }
            
            if (cwKeyState.currentCharacter) {
                const character = reverseMorse[cwKeyState.currentCharacter];
                if (character) {
                    cwKeyState.currentWord += character;
                    userProgress.learnedChars.add(character);
                    userProgress.lettersLearned = userProgress.learnedChars.size;
                } else {
                    cwKeyState.currentWord += '?';
                }
                
                // Update displays
                currentCharDisplay.textContent = 'None';
                currentWordDisplay.textContent = cwKeyState.currentWord || 'None';
                
                cwKeyState.currentCharacter = '';
                updateCwOutput();
                updateProgressDisplay();
                saveProgress();
                
                // Update last key up time for word space calculation
                cwKeyState.lastKeyUpTime = Date.now();
            }
        }

        // Process word space (when a word is complete)
        function processWordSpace() {
            // Process any pending character first
            if (cwKeyState.currentCharacter) {
                processCharacterSpace();
            }
            
            // If we have a current word, add it to output
            if (cwKeyState.currentWord) {
                cwKeyState.outputText += cwKeyState.currentWord + ' ';
                cwKeyState.currentWord = '';
                currentWordDisplay.textContent = 'None';
                updateCwOutput();
            }
        }

        // Update CW output display
        function updateCwOutput() {
            let displayText = cwKeyState.outputText;
            
            // Add current word if exists
            if (cwKeyState.currentWord) {
                displayText += cwKeyState.currentWord;
            }
            
            // Add current character being formed
            if (cwKeyState.currentCharacter) {
                // Add space before character indicator if there's already text
                if (displayText.length > 0 && !displayText.endsWith(' ')) {
                    displayText += ' ';
                }
                displayText += `[${cwKeyState.currentCharacter}]`;
            }
            
            cwOutput.textContent = displayText || 'CW output will appear here...';
            cwOutput.scrollTop = cwOutput.scrollHeight; // Auto-scroll to bottom
            
            // If in practice mode, check if the user is matching the practice text
            if (cwKeyState.practiceMode) {
                checkPracticeProgress();
            }
        }

        // Initialize Flashcard CW Practice
        function initFlashcardCwPractice() {
            updateFlashcardKeyInstruction();
            resetFlashcardCwInput();
        }

        // Update flashcard key instruction
        function updateFlashcardKeyInstruction() {
            const cwMode = keyMode.value; // Use the same mode as main CW Key tab
            if (cwMode === 'touch') {
                flashcardKeyInstruction.textContent = 'Touch and hold here to practice';
            } else if (cwMode === 'keyboard') {
                flashcardKeyInstruction.textContent = 'Press Spacebar or click here to practice';
            } else if (cwMode === 'mouse') {
                flashcardKeyInstruction.textContent = 'Left click for dot, Right click for dash';
            } else {
                flashcardKeyInstruction.textContent = 'Press your CW key to practice';
            }
        }

        // Reset flashcard CW input
        function resetFlashcardCwInput() {
            flashcardCwState.currentCharacter = '';
            flashcardCwState.mouseButtonDown = null;
            flashcardCurrentCharDisplay.textContent = 'None';
            flashcardKeyOutput.classList.add('hidden');
            flashcardCwOutput.textContent = 'Your CW input will appear here...';
            flashcardKeyTestArea.classList.remove('active');
            
            if (flashcardCwState.characterTimeout) {
                clearTimeout(flashcardCwState.characterTimeout);
                flashcardCwState.characterTimeout = null;
            }
        }

        // Update flashcard CW output display
        function updateFlashcardCwOutput() {
            let displayText = '';
            if (flashcardCwState.currentCharacter) {
                displayText = `Your input: [${flashcardCwState.currentCharacter}]`;
            }
            flashcardCwOutput.textContent = displayText || 'Your CW input will appear here...';
            
            // Update current character display
            flashcardCurrentCharDisplay.textContent = flashcardCwState.currentCharacter || 'None';
        }

        // Flashcard key down handler
        function flashcardKeyDown() {
            // Clear any existing character timeout
            if (flashcardCwState.characterTimeout) {
                clearTimeout(flashcardCwState.characterTimeout);
                flashcardCwState.characterTimeout = null;
            }
            
            flashcardCwState.keyDownTime = Date.now();
            flashcardKeyTestArea.classList.add('active');
            flashcardKeyOutput.textContent = 'KEY DOWN';
            flashcardKeyOutput.classList.remove('hidden');
            
            // Play sound if enabled
            if (flashcardCwState.soundEnabled && audioState.audioContext) {
                startTone();
            }
        }

        // Flashcard key up handler
        function flashcardKeyUp() {
            const duration = Date.now() - flashcardCwState.keyDownTime;
            flashcardKeyTestArea.classList.remove('active');
            flashcardKeyOutput.textContent = `KEY UP (${Math.round(duration)}ms)`;
            
            // Stop sound if playing
            if (audioState.isPlaying) {
                stopTone();
            }
            
            // Use the same timing as main CW Key
            if (duration < cwKeyState.dotDuration * 1.5) {
                // Dot
                flashcardCwState.currentCharacter += '.';
                flashcardKeyOutput.textContent += ' - DOT';
            } else {
                // Dash
                flashcardCwState.currentCharacter += '-';
                flashcardKeyOutput.textContent += ' - DASH';
            }
            
            // Set a timeout to complete the character
            flashcardCwState.characterTimeout = setTimeout(() => {
                checkFlashcardCharacter();
            }, cwKeyState.charSpaceDuration);
            
            // Update the last key up time
            flashcardCwState.lastKeyUpTime = Date.now();
            
            // Update output display
            updateFlashcardCwOutput();
        }

        // Flashcard touch start handler
        function flashcardTouchStart() {
            // Clear any existing character timeout
            if (flashcardCwState.characterTimeout) {
                clearTimeout(flashcardCwState.characterTimeout);
                flashcardCwState.characterTimeout = null;
            }
            
            flashcardCwState.keyDownTime = Date.now();
            flashcardKeyTestArea.classList.add('active');
            flashcardKeyOutput.textContent = 'TOUCH START';
            flashcardKeyOutput.classList.remove('hidden');
            
            // Play sound if enabled
            if (flashcardCwState.soundEnabled && audioState.audioContext) {
                startTone();
            }
            
            // Set a timer to show we're in dash mode
            flashcardCwState.touchTimer = setTimeout(() => {
                flashcardKeyOutput.textContent = 'TOUCH START - DASH MODE';
            }, cwKeyState.dotDuration * 1.5);
        }

        // Flashcard touch end handler
        function flashcardTouchEnd() {
            if (!flashcardCwState.keyDownTime) return;
            
            const duration = Date.now() - flashcardCwState.keyDownTime;
            flashcardKeyTestArea.classList.remove('active');
            flashcardKeyOutput.textContent = `TOUCH END (${Math.round(duration)}ms)`;
            
            // Clear the dash mode timer
            if (flashcardCwState.touchTimer) {
                clearTimeout(flashcardCwState.touchTimer);
                flashcardCwState.touchTimer = null;
            }
            
            // Stop sound if playing
            if (audioState.isPlaying) {
                stopTone();
            }
            
            // Determine if it's a dot or dash based on duration
            if (duration < cwKeyState.dotDuration * 1.5) {
                // Dot
                flashcardCwState.currentCharacter += '.';
                flashcardKeyOutput.textContent += ' - DOT';
            } else {
                // Dash
                flashcardCwState.currentCharacter += '-';
                flashcardKeyOutput.textContent += ' - DASH';
            }
            
            // Set a timeout to complete the character
            flashcardCwState.characterTimeout = setTimeout(() => {
                checkFlashcardCharacter();
            }, cwKeyState.charSpaceDuration);
            
            // Update the last key up time
            flashcardCwState.lastKeyUpTime = Date.now();
            
            // Update output display
            updateFlashcardCwOutput();
            
            // Reset key down time
            flashcardCwState.keyDownTime = 0;
        }

        // Check the flashcard character
        function checkFlashcardCharacter() {
            if (flashcardCwState.currentCharacter) {
                const currentChar = currentCardSet[currentCardIndex];
                const targetCode = morseCode[currentChar];
                
                // Update target code display
                flashcardTargetCodeDisplay.textContent = targetCode;
                
                // Compare input with target
                if (flashcardCwState.currentCharacter === targetCode) {
                    flashcardCwOutput.textContent = `✓ Correct! "${currentChar}" = ${targetCode}`;
                    flashcardCwOutput.style.color = '#4CAF50';
                    
                    // Mark as learned
                    userProgress.learnedChars.add(currentChar);
                    userProgress.lettersLearned = userProgress.learnedChars.size;
                    updateProgressDisplay();
                    saveProgress();
                } else {
                    flashcardCwOutput.textContent = `✗ Try again. Your input: ${flashcardCwState.currentCharacter}, Target: ${targetCode}`;
                    flashcardCwOutput.style.color = '#b21f1f';
                }
                
                // Clear current character for next attempt
                flashcardCwState.currentCharacter = '';
                flashcardCurrentCharDisplay.textContent = 'None';
            }
        }

        // Show the target code
        function showFlashcardTargetCode() {
            const currentChar = currentCardSet[currentCardIndex];
            const targetCode = morseCode[currentChar];
            flashcardTargetCodeDisplay.textContent = targetCode;
            
            // Also play the sound
            playCharacter(currentChar);
        }

        // Check practice progress
        function checkPracticeProgress() {
            const expectedChar = reverseMorse[cwKeyState.currentCharacter];
            const targetChar = cwKeyState.practiceText[cwKeyState.practiceIndex];
            
            if (expectedChar === targetChar) {
                // Correct character
                cwKeyState.currentWord += expectedChar;
                cwKeyState.practiceIndex++;
                cwKeyState.currentCharacter = '';
                currentCharDisplay.textContent = 'None';
                currentWordDisplay.textContent = cwKeyState.currentWord || 'None';
                
                // If we've completed the word, move to next word
                if (cwKeyState.practiceText[cwKeyState.practiceIndex] === ' ') {
                    cwKeyState.outputText += cwKeyState.currentWord + ' ';
                    cwKeyState.currentWord = '';
                    currentWordDisplay.textContent = 'None';
                    cwKeyState.practiceIndex++;
                }
                
                updateCwOutput();
            }
            // If incorrect, we wait for the user to complete the character
        }

        // Generate Morse code table
        function generateMorseTable() {
            // Clear existing content
            morseTableElement.innerHTML = '';
            
            // Create table items for each character
            for (const [char, code] of Object.entries(morseCode)) {
                const item = document.createElement('div');
                item.className = 'morse-item';
                
                const charElement = document.createElement('div');
                charElement.className = 'morse-char';
                charElement.textContent = char;
                
                const codeElement = document.createElement('div');
                codeElement.className = 'morse-code';
                codeElement.textContent = code;
                
                item.appendChild(charElement);
                item.appendChild(codeElement);
                
                // Add click event to mark as learned and play sound
                item.addEventListener('click', () => {
                    if (userProgress.learnedChars.has(char)) {
                        userProgress.learnedChars.delete(char);
                        item.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                    } else {
                        userProgress.learnedChars.add(char);
                        item.style.backgroundColor = 'rgba(253, 187, 45, 0.3)';
                        userProgress.lettersLearned = userProgress.learnedChars.size;
                    }
                    
                    // Play the character sound
                    playCharacter(char);
                    
                    updateProgressDisplay();
                    saveProgress();
                });
                
                // Highlight if already learned
                if (userProgress.learnedChars.has(char)) {
                    item.style.backgroundColor = 'rgba(253, 187, 45, 0.3)';
                }
                
                morseTableElement.appendChild(item);
            }
        }

        // Convert text to Morse code
        function textToMorse(text) {
            return text.toUpperCase().split('').map(char => {
                return morseCode[char] || '?';
            }).join(' ');
        }

        // Convert Morse code to text
        function morseToText(morse) {
            return morse.split(' ').map(code => {
                return reverseMorse[code] || '?';
            }).join('');
        }

        // Generate card set based on selected type
        function generateCardSet() {
            const cardType = cardTypeElement.value;
            currentCardSet = [];
            
            if (cardType === 'letters') {
                // Add only letters
                for (let i = 65; i <= 90; i++) {
                    currentCardSet.push(String.fromCharCode(i));
                }
            } else if (cardType === 'numbers') {
                // Add only numbers
                for (let i = 0; i <= 9; i++) {
                    currentCardSet.push(i.toString());
                }
            } else {
                // Add both letters and numbers
                for (let i = 65; i <= 90; i++) {
                    currentCardSet.push(String.fromCharCode(i));
                }
                for (let i = 0; i <= 9; i++) {
                    currentCardSet.push(i.toString());
                }
            }
            
            // Reset card index
            currentCardIndex = 0;
        }

        // Show current flashcard
        function showCard() {
            if (currentCardSet.length === 0) return;
            
            const char = currentCardSet[currentCardIndex];
            flashcardCharElement.textContent = char;
            flashcardCodeElement.textContent = morseCode[char];
            
            // Hide the code initially
            flashcardCodeElement.classList.add('hidden');
            
            // Reset flashcard CW practice
            resetFlashcardCwInput();
            flashcardTargetCodeDisplay.textContent = '?';
            flashcardCwOutput.textContent = 'Your CW input will appear here...';
            flashcardCwOutput.style.color = 'inherit';
            
            // Increment flashcards viewed counter
            userProgress.flashcardsViewed++;
            updateProgressDisplay();
            saveProgress();
        }

        // Update progress display
        function updateProgressDisplay() {
            lettersLearnedElement.textContent = userProgress.lettersLearned;
            practiceSessionsElement.textContent = userProgress.practiceSessions;
            flashcardsViewedElement.textContent = userProgress.flashcardsViewed;
            
            // Calculate overall progress (based on learned characters)
            const totalChars = Object.keys(morseCode).length;
            const progressPercent = (userProgress.learnedChars.size / totalChars) * 100;
            overallProgressElement.style.width = `${progressPercent}%`;
        }

        // Load progress from localStorage
        function loadProgress() {
            const savedProgress = localStorage.getItem('morseCodeProgress');
            if (savedProgress) {
                const parsed = JSON.parse(savedProgress);
                userProgress.lettersLearned = parsed.lettersLearned || 0;
                userProgress.practiceSessions = parsed.practiceSessions || 0;
                userProgress.flashcardsViewed = parsed.flashcardsViewed || 0;
                userProgress.learnedChars = new Set(parsed.learnedChars || []);
            }
        }

        // Save progress to localStorage
        function saveProgress() {
            localStorage.setItem('morseCodeProgress', JSON.stringify({
                lettersLearned: userProgress.lettersLearned,
                practiceSessions: userProgress.practiceSessions,
                flashcardsViewed: userProgress.flashcardsViewed,
                learnedChars: Array.from(userProgress.learnedChars)
            }));
        }

        // Set up event listeners
        function setupEventListeners() {
            // Tab navigation
            tabElements.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Remove active class from all tabs and content
                    tabElements.forEach(t => t.classList.remove('active'));
                    tabContentElements.forEach(c => c.classList.remove('active'));
                    
                    // Add active class to clicked tab and corresponding content
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.tab).classList.add('active');
                });
            });
            
            // Convert text to Morse
            convertToMorseButton.addEventListener('click', () => {
                const text = textInputElement.value;
                if (text.trim()) {
                    const morse = textToMorse(text);
                    practiceResultElement.textContent = morse;
                    userProgress.practiceSessions++;
                    updateProgressDisplay();
                    saveProgress();
                }
            });
            
            // Convert Morse to text
            convertToTextButton.addEventListener('click', () => {
                const morse = morseInputElement.value;
                if (morse.trim()) {
                    const text = morseToText(morse);
                    practiceResultElement.textContent = text;
                    userProgress.practiceSessions++;
                    updateProgressDisplay();
                    saveProgress();
                }
            });
            
            // Play text as Morse audio
            playTextButton.addEventListener('click', () => {
                const text = textInputElement.value;
                if (text.trim()) {
                    playMorseFromText(text);
                    userProgress.practiceSessions++;
                    updateProgressDisplay();
                    saveProgress();
                }
            });
            
            // Play Morse as audio
            playMorseButton.addEventListener('click', () => {
                const morse = morseInputElement.value;
                if (morse.trim()) {
                    // Convert Morse to text and then play as audio
                    const text = morseToText(morse);
                    playMorseFromText(text);
                    userProgress.practiceSessions++;
                    updateProgressDisplay();
                    saveProgress();
                }
            });
            
            // Flashcard navigation
            prevCardButton.addEventListener('click', () => {
                if (currentCardSet.length === 0) return;
                currentCardIndex = (currentCardIndex - 1 + currentCardSet.length) % currentCardSet.length;
                showCard();
            });
            
            nextCardButton.addEventListener('click', () => {
                if (currentCardSet.length === 0) return;
                currentCardIndex = (currentCardIndex + 1) % currentCardSet.length;
                showCard();
            });
            
            // Flip flashcard
            flipCardButton.addEventListener('click', () => {
                flashcardCodeElement.classList.toggle('hidden');
            });
            
            // Flip flashcard on click
            flashcardElement.addEventListener('click', () => {
                flashcardCodeElement.classList.toggle('hidden');
            });
            
            // Play flashcard sound
            playCardSoundButton.addEventListener('click', () => {
                const char = currentCardSet[currentCardIndex];
                playCharacter(char);
            });
            
            // Change card type
            cardTypeElement.addEventListener('change', () => {
                generateCardSet();
                showCard();
            });
            
            // Reset progress
            resetProgressButton.addEventListener('click', () => {
                if (confirm('Are you sure you want to reset all progress and settings?')) {
                    userProgress = {
                        lettersLearned: 0,
                        practiceSessions: 0,
                        flashcardsViewed: 0,
                        learnedChars: new Set()
                    };
                    
                    // Also reset audio and CW settings to defaults
                    localStorage.removeItem('morseCodeAudioSettings');
                    localStorage.removeItem('morseCodeCwSettings');
                    
                    // Reload default settings
                    loadAudioSettings();
                    loadCwSettings();
                    
                    updateProgressDisplay();
                    saveProgress();
                    generateMorseTable();
                }
            });
            
            // CW Key event listeners
            cwSpeed.addEventListener('input', () => {
                cwKeyState.speed = parseInt(cwSpeed.value);
                speedValue.textContent = `${cwKeyState.speed} WPM`;
                updateCwTiming();
                saveCwSettings();
            });

            keyMode.addEventListener('change', () => {
                updateKeyInstruction();
                updateFlashcardKeyInstruction();
                saveCwSettings();
            });
            
            connectKeyButton.addEventListener('click', () => {
                if (cwKeyState.connected) {
                    disconnectSerial();
                } else {
                    if (keyMode.value === 'serial') {
                        connectSerial();
                    } else {
                        // For keyboard/touch/mouse mode, we simulate connection
                        cwKeyState.connected = true;
                        statusIndicator.classList.add('connected');
                        statusText.textContent = `${keyMode.value.charAt(0).toUpperCase() + keyMode.value.slice(1)} mode active`;
                        connectKeyButton.textContent = 'Disconnect Key';
                    }
                }
            });
            
            clearOutputButton.addEventListener('click', () => {
                cwKeyState.outputText = '';
                cwKeyState.currentWord = '';
                cwKeyState.currentCharacter = '';
                currentCharDisplay.textContent = 'None';
                currentWordDisplay.textContent = 'None';
                
                // Clear any pending timeouts
                if (cwKeyState.characterTimeout) {
                    clearTimeout(cwKeyState.characterTimeout);
                    cwKeyState.characterTimeout = null;
                }
                
                updateCwOutput();
            });
            
            practiceModeButton.addEventListener('click', () => {
                cwKeyState.practiceMode = !cwKeyState.practiceMode;
                if (cwKeyState.practiceMode) {
                    practiceModeButton.textContent = 'Exit Practice';
                    cwKeyState.practiceText = generatePracticeText();
                    cwKeyState.practiceIndex = 0;
                    cwKeyState.outputText = 'Practice: ' + cwKeyState.practiceText + '\n\nYour input: ';
                    updateCwOutput();
                } else {
                    practiceModeButton.textContent = 'Practice Mode';
                    cwKeyState.outputText = '';
                    updateCwOutput();
                }
            });
            
            enableSoundButton.addEventListener('click', () => {
                cwKeyState.soundEnabled = !cwKeyState.soundEnabled;
                if (cwKeyState.soundEnabled) {
                    enableSoundButton.textContent = 'Disable Sound';
                    enableSoundButton.style.backgroundColor = '#4CAF50';
                } else {
                    enableSoundButton.textContent = 'Enable Sound';
                    enableSoundButton.style.backgroundColor = '#fdbb2d';
                }
                saveCwSettings();
            });
            
            // Keyboard input for CW key
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !e.repeat && (keyMode.value === 'keyboard' || keyMode.value === 'touch')) {
                    e.preventDefault();
                    keyDown();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space' && (keyMode.value === 'keyboard' || keyMode.value === 'touch')) {
                    e.preventDefault();
                    keyUp();
                }
            });
            
            // Mouse events for CW key (mouse mode)
            document.addEventListener('mousedown', (e) => {
                if (keyMode.value === 'mouse') {
                    handleMouseDown(e);
                }
            });
            
            document.addEventListener('mouseup', (e) => {
                if (keyMode.value === 'mouse') {
                    handleMouseUp(e);
                }
            });
            
            // Prevent context menu on right click in mouse mode
            keyTestArea.addEventListener('contextmenu', (e) => {
                if (keyMode.value === 'mouse') {
                    e.preventDefault();
                    return false;
                }
            });
            
            // Mouse and touch events for CW key test area
            keyTestArea.addEventListener('mousedown', (e) => {
                e.preventDefault();
                if (keyMode.value === 'keyboard' || keyMode.value === 'touch') {
                    keyDown();
                }
            });
            
            keyTestArea.addEventListener('mouseup', (e) => {
                e.preventDefault();
                if (keyMode.value === 'keyboard' || keyMode.value === 'touch') {
                    keyUp();
                }
            });
            
            keyTestArea.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (keyMode.value === 'touch') {
                    touchStart();
                }
            });
            
            keyTestArea.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (keyMode.value === 'touch') {
                    touchEnd();
                }
            });

            // Audio event listeners
            audioFrequencyElement.addEventListener('input', () => {
                audioState.frequency = parseInt(audioFrequencyElement.value);
                frequencyValueElement.textContent = `${audioState.frequency} Hz`;
                saveAudioSettings();
            });

            audioSpeedElement.addEventListener('input', () => {
                audioState.speed = parseInt(audioSpeedElement.value);
                audioSpeedValueElement.textContent = `${audioState.speed} WPM`;
                updateAudioTiming();
                saveAudioSettings();
            });

            audioVolumeElement.addEventListener('input', () => {
                audioState.volume = parseInt(audioVolumeElement.value) / 100;
                volumeValueElement.textContent = `${audioVolumeElement.value}%`;
                saveAudioSettings();
            });
            
            playAudioTextButton.addEventListener('click', () => {
                const text = audioTextElement.value;
                if (text.trim()) {
                    playMorseFromText(text);
                }
            });
            
            stopAudioButton.addEventListener('click', () => {
                stopAudio();
            });
            
            randomTextButton.addEventListener('click', () => {
                audioTextElement.value = generateRandomText();
            });
            
            // Practice phrases event listeners
            addPhraseButton.addEventListener('click', addPracticePhrase);
            
            getRandomPhraseButton.addEventListener('click', getRandomPracticePhrase);
            
            exportPhrasesButton.addEventListener('click', exportPhrases);
            
            importPhrasesButton.addEventListener('click', importPhrases);
            
            clearPhrasesButton.addEventListener('click', () => {
                if (confirm('Are you sure you want to clear all practice phrases?')) {
                    practicePhrases.phrases = [];
                    savePracticePhrases();
                    updatePhrasesDisplay();
                }
            });
            
            loadDefaultPhrasesButton.addEventListener('click', loadDefaultPhrases);
            
            // Allow Enter key to add phrase in new phrase textarea
            newPhraseElement.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && e.ctrlKey) {
                    e.preventDefault();
                    addPracticePhrase();
                }
            });

            // Flashcard CW Practice event listeners

            // Flashcard Key Test Area mouse events for mouse mode
            flashcardKeyTestArea.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const cwMode = keyMode.value;
                
                if (cwMode === 'mouse') {
                    // Handle mouse buttons for dots and dashes
                    if (e.button === 0 || e.button === 2) {
                        e.preventDefault();
                        flashcardMouseDown(e);
                    }
                } else if (cwMode === 'keyboard' || cwMode === 'touch') {
                    flashcardKeyDown();
                }
            });

            flashcardKeyTestArea.addEventListener('mouseup', (e) => {
                e.preventDefault();
                const cwMode = keyMode.value;
                
                if (cwMode === 'mouse') {
                    // Handle mouse buttons for dots and dashes
                    if (e.button === 0 || e.button === 2) {
                        e.preventDefault();
                        flashcardMouseUp(e);
                    }
                } else if (cwMode === 'keyboard' || cwMode === 'touch') {
                    flashcardKeyUp();
                }
            });

            // Flashcard mouse down handler for mouse mode
            function flashcardMouseDown(event) {
                if (keyMode.value !== 'mouse') return;
                
                // Prevent context menu on right click
                if (event.button === 2) {
                    event.preventDefault();
                }
                
                // Clear any existing character timeout
                if (flashcardCwState.characterTimeout) {
                    clearTimeout(flashcardCwState.characterTimeout);
                    flashcardCwState.characterTimeout = null;
                }
                
                flashcardCwState.mouseButtonDown = event.button;
                flashcardCwState.keyDownTime = Date.now();
                flashcardKeyTestArea.classList.add('active');
                
                // Update display based on which button
                if (event.button === 0) {
                    flashcardKeyOutput.textContent = 'MOUSE DOWN - LEFT (DOT)';
                } else if (event.button === 2) {
                    flashcardKeyOutput.textContent = 'MOUSE DOWN - RIGHT (DASH)';
                }
                flashcardKeyOutput.classList.remove('hidden');
                
                // Play sound if enabled
                if (flashcardCwState.soundEnabled && audioState.audioContext) {
                    startTone();
                }
            }

            // Flashcard mouse up handler for mouse mode
            function flashcardMouseUp(event) {
                if (keyMode.value !== 'mouse' || flashcardCwState.mouseButtonDown === null) return;
                
                // Only process if the same button is released
                if (event.button !== flashcardCwState.mouseButtonDown) return;
                
                const duration = Date.now() - flashcardCwState.keyDownTime;
                
                // Stop sound if playing
                if (audioState.isPlaying) {
                    stopTone();
                }
                
                flashcardKeyTestArea.classList.remove('active');
                flashcardKeyOutput.textContent = `MOUSE UP (${Math.round(duration)}ms)`;
                
                // Add dot or dash based on which button was pressed
                if (event.button === 0) {
                    // Left button = dot
                    flashcardCwState.currentCharacter += '.';
                    flashcardKeyOutput.textContent += ' - LEFT (DOT)';
                } else if (event.button === 2) {
                    // Right button = dash
                    flashcardCwState.currentCharacter += '-';
                    flashcardKeyOutput.textContent += ' - RIGHT (DASH)';
                }
                
                // Set a timeout to complete the character
                flashcardCwState.characterTimeout = setTimeout(() => {
                    checkFlashcardCharacter();
                }, cwKeyState.charSpaceDuration);
                
                // Update the last key up time
                flashcardCwState.lastKeyUpTime = Date.now();
                
                // Update output display
                updateFlashcardCwOutput();
                
                // Reset mouse button state
                flashcardCwState.mouseButtonDown = null;
            }

            // Prevent context menu on right click in mouse mode
            flashcardKeyTestArea.addEventListener('contextmenu', (e) => {
                if (keyMode.value === 'mouse') {
                    e.preventDefault();
                    return false;
                }
            });

            flashcardKeyTestArea.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (keyMode.value === 'touch') {
                    flashcardTouchStart();
                }
            });

            flashcardKeyTestArea.addEventListener('touchend', (e) => {
                e.preventDefault();
                if (keyMode.value === 'touch') {
                    flashcardTouchEnd();
                }
            });

            flashcardClearKeyButton.addEventListener('click', () => {
                resetFlashcardCwInput();
            });

            flashcardCheckCodeButton.addEventListener('click', () => {
                checkFlashcardCharacter();
            });

            flashcardShowCodeButton.addEventListener('click', () => {
                showFlashcardTargetCode();
            });

            // Use the same keyboard input as main CW Key
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !e.repeat) {
                    // Check if we're in the flashcard tab
                    const flashcardTab = document.getElementById('flashcards');
                    if (flashcardTab.classList.contains('active')) {
                        e.preventDefault();
                        flashcardKeyDown();
                    }
                }
            });

            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    // Check if we're in the flashcard tab
                    const flashcardTab = document.getElementById('flashcards');
                    if (flashcardTab.classList.contains('active')) {
                        e.preventDefault();
                        flashcardKeyUp();
                    }
                }
            });

            // Update flashcard instructions when CW mode changes
            keyMode.addEventListener('change', () => {
                updateFlashcardKeyInstruction();
            });
        }

        // Initialize the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
    
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js')
            .then(() => console.log('Service Worker successfully registered.'))
            .catch(err => console.error('Erro SW:', err));
        }
    </script>

    <div id="offlineNotification" style="display: none; position: fixed; top: 0; left: 0; right: 0; background: #b21f1f; color: white; text-align: center; padding: 10px; z-index: 1000;">
    ⚠️ You are offline. Some features may be limited.
    </div>

    <script>
        // Checks connection status
        function updateOnlineStatus() {
            const offlineNotification = document.getElementById('offlineNotification');
            if (!navigator.onLine) {
                offlineNotification.style.display = 'block';
                setTimeout(function() {
                    offlineNotification.style.display = 'none';
                }, 5000); // Hide after 5 seconds
                console.log('Application in offline mode');
            } else {
                offlineNotification.style.display = 'none';
                console.log('Online application');
            }
        }

        // Event listeners for connection changes
        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);
        
        // Check initial status
        updateOnlineStatus();
    </script>
</body>
</html>